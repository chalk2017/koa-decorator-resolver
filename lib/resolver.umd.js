!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.injectorBuilder=exports.restfulBinder=exports.routeBinder=exports.servInjector=exports.injectRemove=exports.injectBind=exports.Post=exports.Get=exports.ormConnectionCreate=exports.connectionCreate=exports.defineTables=void 0;const a=require("sequelize"),r=require("sqlite3"),n=require("sqlite");exports.defineTables=class{tablesStructure;relation;sequelize;sqlite;sqlite3;constructor(e,t,r,a,n){this.tablesStructure=e,this.relation=t,this.sequelize=r,this.sqlite=a,this.sqlite3=n}declareTables(r,e,a){const n={freezeTableName:!0,timestamps:!1};let s={};return e&&0<e.length?e.forEach(e=>{var t=this.tablesStructure[e]({s:r,o:n,t:e});s[e]=a?this.useTransaction(t,a):t}):Object.keys(this.tablesStructure).forEach(e=>{var t=this.tablesStructure[e]({s:r,o:n,t:e});s[e]=a?this.useTransaction(t,a):t}),this.relation(s),s}useTransaction(r,a){const n={create:async(e,t)=>r.create(e,{transaction:a,...t}),update:async(e,t)=>r.update(e,{transaction:a,...t}),destroy:async e=>r.destroy({transaction:a,...e}),bulkCreate:async(e,t)=>r.bulkCreate(e,{transaction:a,...t}),findAll:async e=>r.findAll({transaction:a,...e}),findOne:async e=>r.findOne({transaction:a,...e}),max:async(e,t)=>r.max(e,{transaction:a,...t}),min:async(e,t)=>r.min(e,{transaction:a,...t}),sum:async(e,t)=>r.sum(e,{transaction:a,...t})};return new Proxy(r,{get(e,t,r){return n[t]||Reflect.get(e,t,r)}})}Sqlite(c){return(i,e,{configurable:t,enumerable:r,value:l,writable:a})=>{return{configurable:t,enumerable:r,value:async(...e)=>{var r=c?.autoClose??!0,a=c?.useTransaction??!1;let n;if(c?.useOrm){const o=await(0,exports.ormConnectionCreate)(this.sequelize)();let t=null;a&&(t=await o.transaction());var s=this.declareTables(o,c.tables,t);i.db={sequelize:o,tables:s,transaction:t};try{n=await l.apply(i,e),a&&t.commit()}catch(e){throw t.rollback(),e}r&&!a&&await o.close()}else{const t=await(0,exports.connectionCreate)(this.sqlite,this.sqlite3)();i.db=t,n=await l.apply(i,e),r&&await t.close()}return n},writable:a}}}};exports.connectionCreate=(e,t)=>async()=>{try{return await n.open({filename:require(require("path").resolve("db.sqlite.js")).path,driver:r.Database})}catch(e){}};exports.ormConnectionCreate=e=>async()=>{try{let e=[{dialect:"sqlite",storage:require(require("path").resolve("db.sqlite.js")).path}];var t=s(),r=(t&&(e=t),new a.Sequelize(...e));return r}catch(e){}};const s=()=>{var e,t=require("dotenv").config()["parsed"];return"sqlite"!==t.DB_DRIVER?"mysql"===t.DB_DRIVER?[(e=require(require("path").resolve("db.mysql.js"))).database,e.username,e.password,{host:e.host,port:e.port,dialect:"mysql"}]:(t.DB_DRIVER,null):[{dialect:"sqlite",storage:require(require("path").resolve("db.sqlite.js")).path}]};exports.Get=o=>{return(t,e,{configurable:r,enumerable:a,value:n,writable:s})=>{return t.$restful?t.$restful[e]={url:o,method:"get"}:t.$restful={[e]:{url:o,method:"get"}},{configurable:r,enumerable:a,value:async(...e)=>{return await n.apply(t,e)},writable:s}}},exports.Post=o=>{return(t,e,{configurable:r,enumerable:a,value:n,writable:s})=>{return t.$restful?t.$restful[e]={url:o,method:"post"}:t.$restful={[e]:{url:o,method:"post"}},{configurable:r,enumerable:a,value:async(...e)=>{return await n.apply(t,e)},writable:s}}},exports.injectBind=(e,t,r)=>{e.$inject||(e.$inject={});for(const a in r)e.$inject[a]?e.$inject[a][t]=r[a]:e.$inject[a]={[t]:r[a]}},exports.injectRemove=(e,t,r)=>{e.$inject||(e.$inject={}),e.$inject[t]&&(r?delete e.$inject[t][r]:delete e.$inject[t])},exports.servInjector=(p,f,d)=>{let e="post";for(const t in d)if(d[t].method&&p?.$inject&&p?.$inject[t]&&p?.$inject[t][f]){e=d[t].method;break}return[e,async e=>{const t={};let r=null;for(const i in d)if(d[i].before){const l=d[i].before.plugin;var a;p?.$inject&&p?.$inject[i]&&p?.$inject[i][f]&&(a=await l(e,p?.$inject[i][f]?.option),t[i]=a,d[i].before.replaceProps&&(r=a))}t.data=e.request.body,null===r&&(r=t.data);var n,s=await p[f](r,t,e);let o=!1;for(const c in d)if(d[c].after){const u=d[c].after.plugin;p?.$inject&&p?.$inject[c]&&p?.$inject[c][f]&&(n=await u(s,e,p?.$inject[c][f]?.option),t[c]=n,o=!0,d[c].after.replaceProps&&(e.body=n))}o||(e.body=s)}]},exports.routeBinder=(e,t,r)=>{const a={};for(var n in t){var s,o=t[n],i=Object.getOwnPropertyNames(o.prototype).filter(e=>"constructor"!==e&&"$inject"!==e),l=Reflect.construct(o,[]);for(s of i){var[u,c]=(0,exports.servInjector)(l,s,r);e[u](`/${n}/`+s,c),a[n+"_"+s]=c}}return a},exports.restfulBinder=(e,t)=>{const a={};for(var r in t){var r=t[r],n=Object.getOwnPropertyNames(r.prototype).filter(e=>"constructor"!==e&&"$restful"!==e);const o=Reflect.construct(r,[]);for(let r of n){const{url:i,method:l}=o.$restful[r];var s=async e=>{if("get"===l?.toLowerCase()){var t=e["params"],t=await o[r](t||{},e);e.body=t}else if("post"===l?.toLowerCase()){t=e.request.body,t=await o[r](t,e);e.body=t}else if("put"===l?.toLowerCase()){t=e.request.body,t=await o[r](t,e);e.body=t}else{if("delete"!==l?.toLowerCase())return o[r](e);t=e["params"],t=await o[r](t||{},e);e.body=t}};"get"===l?.toLowerCase()?e.get(i,s):"post"===l?.toLowerCase()?e.post(i,s):"put"===l?.toLowerCase()?e.put(i,s):"delete"===l?.toLowerCase()?e.delete(i,s):e[l](i,s),a[""+i]=s}}return a};exports.injectorBuilder=(i,e)=>{const l=e?.onCreate||(()=>""),c=e?.onBefore||((...e)=>e),u=e?.onAfter||(e=>e);return o=>{return(t,e,{configurable:r,enumerable:a,value:n,writable:s})=>{l(t,e);return(0,exports.injectBind)(t,e,{[i]:{option:o}}),{configurable:r,enumerable:a,value:async(...e)=>{e=await c(...e),e=await n.apply(t,e);return await u(e)},writable:s}}}}});
