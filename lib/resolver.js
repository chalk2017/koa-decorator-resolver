Object.defineProperty(exports,"__esModule",{value:!0}),exports.injectorBuilder=exports.restfulBinder=exports.routeBinder=exports.servInjector=exports.injectRemove=exports.injectBind=exports.Post=exports.Get=exports.ormConnectionCreate=exports.connectionCreate=exports.defineTables=void 0;const sequelize_1=require("sequelize");class defineTables{tablesStructure;relation;sequelize;sqlite;sqlite3;constructor(e,t,r,n,a){this.tablesStructure=e,this.relation=t,this.sequelize=r,this.sqlite=n,this.sqlite3=a}declareTables(r,e,n){const a=this,o={freezeTableName:!0,timestamps:!1};let s={};return e&&0<e.length?e.forEach(e=>{var t=a.tablesStructure[e]({s:r,o:o,t:e});s[e]=n?a.useTransaction(t,n):t}):Object.keys(a.tablesStructure).forEach(e=>{var t=a.tablesStructure[e]({s:r,o:o,t:e});s[e]=n?a.useTransaction(t,n):t}),a.relation(s),s}useTransaction(r,n){const a={create:async(e,t)=>r.create(e,{transaction:n,...t}),update:async(e,t)=>r.update(e,{transaction:n,...t}),destroy:async e=>r.destroy({transaction:n,...e}),bulkCreate:async(e,t)=>r.bulkCreate(e,{transaction:n,...t}),findAll:async e=>r.findAll({transaction:n,...e}),findOne:async e=>r.findOne({transaction:n,...e}),max:async(e,t)=>r.max(e,{transaction:n,...t}),min:async(e,t)=>r.min(e,{transaction:n,...t}),sum:async(e,t)=>r.sum(e,{transaction:n,...t})};return new Proxy(r,{get(e,t,r){return a[t]||Reflect.get(e,t,r)}})}Sqlite(c){const u=this;return(i,e,{configurable:t,enumerable:r,value:l,writable:n})=>{return{configurable:t,enumerable:r,value:async(...e)=>{var r=c?.autoClose??!0,n=c?.useTransaction??!1;let a;if(c?.useOrm){const s=await(0,exports.ormConnectionCreate)(u.sequelize)();let t=null;n&&(t=await s.transaction());var o=u.declareTables(s,c.tables,t);i.db={sequelize:s,tables:o,transaction:t};try{a=await l.apply(i,e),n&&t.commit()}catch(e){throw n&&t.rollback(),e}r&&!n&&await s.close()}else{const t=await(0,exports.connectionCreate)(u.sqlite,u.sqlite3)();i.db=t,a=await l.apply(i,e),r&&await t.close()}return a},writable:n}}}}exports.defineTables=defineTables;const connectionCreate=(e,t)=>async()=>{try{var e=require("sqlite3");const t=require("sqlite");return await t.open({filename:require(require("path").resolve("db.sqlite.js")).path,driver:e.Database})}catch(e){}},ormConnectionCreate=(exports.connectionCreate=connectionCreate,e=>async()=>{try{let e=[{dialect:"sqlite",storage:require(require("path").resolve("db.sqlite.js")).path}];var t=loadConfig(),r=(t&&(e=t),new sequelize_1.Sequelize(...e));return r}catch(e){}}),loadConfig=(exports.ormConnectionCreate=ormConnectionCreate,()=>{var e,t=require("dotenv").config()["parsed"];return"sqlite"!==t.DB_DRIVER?"mysql"===t.DB_DRIVER?[(e=require(require("path").resolve("db.mysql.js"))).database,e.username,e.password,{host:e.host,port:e.port,dialect:"mysql"}]:(t.DB_DRIVER,null):[{dialect:"sqlite",storage:require(require("path").resolve("db.sqlite.js")).path}]}),Get=s=>{return(t,e,{configurable:r,enumerable:n,value:a,writable:o})=>{return t.$restful?t.$restful[e]={url:s,method:"get"}:t.$restful={[e]:{url:s,method:"get"}},{configurable:r,enumerable:n,value:async(...e)=>{return await a.apply(t,e)},writable:o}}},Post=(exports.Get=Get,s=>{return(t,e,{configurable:r,enumerable:n,value:a,writable:o})=>{return t.$restful?t.$restful[e]={url:s,method:"post"}:t.$restful={[e]:{url:s,method:"post"}},{configurable:r,enumerable:n,value:async(...e)=>{return await a.apply(t,e)},writable:o}}}),injectBind=(exports.Post=Post,(e,t,r)=>{e.$inject||(e.$inject={});for(const n in r)e.$inject[n]?e.$inject[n][t]=r[n]:e.$inject[n]={[t]:r[n]}}),injectRemove=(exports.injectBind=injectBind,(e,t,r)=>{e.$inject||(e.$inject={}),e.$inject[t]&&(r?delete e.$inject[t][r]:delete e.$inject[t])}),servInjector=(exports.injectRemove=injectRemove,(p,d,f)=>{let e="post";for(const t in f)if(f[t].method&&p?.$inject&&p?.$inject[t]&&p?.$inject[t][d]){e=f[t].method;break}return[e,async e=>{const t={};let r=null;for(const i in f)if(f[i].before){const l=f[i].before.plugin;var n;p?.$inject&&p?.$inject[i]&&p?.$inject[i][d]&&(n=await l(e,p?.$inject[i][d]?.option),t[i]=n,f[i].before.replaceProps&&(r=n))}t.data=e.request.body,null===r&&(r=t.data);var a,o=await p[d](r,t,e);let s=!1;for(const c in f)if(f[c].after){const u=f[c].after.plugin;p?.$inject&&p?.$inject[c]&&p?.$inject[c][d]&&(a=await u(o,e,p?.$inject[c][d]?.option),t[c]=a,s=!0,f[c].after.replaceProps&&(e.body=a))}s||(e.body=o)}]}),routeBinder=(exports.servInjector=servInjector,(e,t,r)=>{const n={};for(var a in t){var o,s=t[a],i=Object.getOwnPropertyNames(s.prototype).filter(e=>"constructor"!==e&&"$inject"!==e),l=Reflect.construct(s,[]);for(o of i){var[u,c]=(0,exports.servInjector)(l,o,r);e[u](`/${a}/`+o,c),n[a+"_"+o]=c}}return n}),restfulBinder=(exports.routeBinder=routeBinder,(e,t)=>{const n={};for(var r in t){var r=t[r],a=Object.getOwnPropertyNames(r.prototype).filter(e=>"constructor"!==e&&"$restful"!==e);const s=Reflect.construct(r,[]);for(let r of a){const{url:i,method:l}=s.$restful[r];var o=async e=>{if("get"===l?.toLowerCase()){var t=e["params"],t=await s[r](t||{},e);e.body=t}else if("post"===l?.toLowerCase()){t=e.request.body,t=await s[r](t,e);e.body=t}else if("put"===l?.toLowerCase()){t=e.request.body,t=await s[r](t,e);e.body=t}else{if("delete"!==l?.toLowerCase())return s[r](e);t=e["params"],t=await s[r](t||{},e);e.body=t}};"get"===l?.toLowerCase()?e.get(i,o):"post"===l?.toLowerCase()?e.post(i,o):"put"===l?.toLowerCase()?e.put(i,o):"delete"===l?.toLowerCase()?e.delete(i,o):e[l](i,o),n[""+i]=o}}return n}),injectorBuilder=(exports.restfulBinder=restfulBinder,(i,e)=>{const l=e?.onCreate||(()=>""),c=e?.onBefore||((...e)=>e),u=e?.onAfter||(e=>e);return s=>{return(t,e,{configurable:r,enumerable:n,value:a,writable:o})=>{l(t,e);return(0,exports.injectBind)(t,e,{[i]:{option:s}}),{configurable:r,enumerable:n,value:async(...e)=>{e=await c(...e),e=await a.apply(t,e);return await u(e)},writable:o}}}});exports.injectorBuilder=injectorBuilder;
